# This scripts computes the transmitted pulse through air containing water vapor
# 1) The absorption spectrum for water vapor in air is calculated for a certain temperature, pressure, and humidity
# 2) The transfer function is calculated by taking into account the travelled distance through air d
#    A renormalization is taken by applying the inverse phase
# 3) A artificial terahertz pulse is generated taking into account the fitted terahertz pulse to the Tera-K15 system
#    measurement in transmission geometry
# 4) Resulting terahertz pulse is generated by flipping the transfer function of water and convolving it with the
#    terahertz pulse
#
# Implementation is missing of the relative humidity.
from idlelib.pyparse import trans

from hapi import *
import numpy as np
import matplotlib.pyplot as plt
from scipy.constants import speed_of_light
from elli.kkr.kkr import im2re, im2re_reciprocal
from scipy.signal.windows import tukey
#from scipy.signal import resample

plot = True

speed_of_light_cmps = speed_of_light*100    # Speed of light in cm^-1
dt = 33.3333e-15                            # Target sampling frequency
impulse_response_length = 1*1e-9            # Duration of desired impulse response

count_of_timepoints = int(np.floor(impulse_response_length / dt/ 3))
freq_vector = np.fft.rfftfreq(count_of_timepoints, dt)
t_vector = np.arange(count_of_timepoints)*dt
w_vector = 2*np.pi*freq_vector

def dgmm(timeaxis, t0, mu1, mu2, sigma1, sigma2, a1, a2):
    """
    Generates double gaussian distribution with the given parameters
    """
    timeaxis = timeaxis*1e12
    mu1 = mu1*1e12
    mu2 = mu2*1e12
    t0 = t0*1e12
    average_position = (mu2+mu1)/2
    mu1 = mu1-average_position+t0
    mu2 = mu2-average_position+t0

    return a1*np.exp(-((timeaxis-mu1)**2)/(2*sigma1**2))+a2*np.exp(-((timeaxis-mu2)**2)/(2*sigma2**2))

# Start frequency and stop frequency where the spectrum should be calculated in
start_frequency = freq_vector[0]
stop_frequency = freq_vector[-1]

step_frequency = freq_vector[1]-freq_vector[0]

start_frequency = 0
stop_frequency = 8e12

# Wavelength calculation
start_nu = start_frequency/speed_of_light_cmps
stop_nu = stop_frequency/speed_of_light_cmps
step_nu = step_frequency/speed_of_light_cmps
omega_grid = freq_vector/speed_of_light_cmps

print("Impulse response length: ", impulse_response_length)
print("Sampling time: ", dt)
print("f_start: ", freq_vector[0]*1e-12, "THz")
print("f_stop: ", freq_vector[-1]*1e-12, "THz")
print("Number of points", count_of_timepoints)

# The absorption spectrum must be recalculated when one of the following quantities has been changed:
# start_wavelength; stop_wavelength, wavelength step, air pressure, temperature.
# Concentrations can be caluclated afterwards

environment = {
    'pressure': 1,
    'temperature': 22+273.15,
    'relative_humidity': 0.55           # TODO Values must be specified
}

# Concentrations in volume percent for calculating the absorption in the volume
concentrations = {
    'N2': 0.78084,    # 0.78084, Stickstoff
    'O2': 0.20942,    # 20.942% Sauerstoff
    'CO2': 0.00040,   # 0.0415% Kohlendioxid (415 ppm)
    'H2O': 0.008      # 0.8% Wasserdampf (kann variieren), Hier 21°C und 55% rel. Luftfeuchtigkeit
                      # TODO mus be calculated from relative humidity
}

# Init Database
db_begin('data')

# Get Molecules and save into database, have to be fetched one time for
# fetch('N2', 22, 1, start_nu, stop_nu)
# fetch('O2', 7, 1, start_nu, stop_nu)
# fetch('CO2', 2, 1, start_nu, stop_nu)
# fetch('H2O', 1, 1, start_nu, stop_nu)
# fetch('Ar', 1, 1, start_nu, stop_nu)

# Calculate spectras for every molecule
absorption_coeffs = 0
for molecule, concentration in concentrations.items():
    nu, coef = absorptionCoefficient_Voigt(
        SourceTables=molecule,
        Environment={'p': environment['pressure'], 'T': environment['temperature']},
        HITRAN_units=False,
        Diluent={'self': concentration, 'air': (1 - concentration)},
        WavenumberStep=step_nu,
        WavenumberRange=[start_nu, stop_nu]
    )

    # coef is the absorption coefficient per cm
    absorption_coeffs += coef * concentration

# Convert into absorption per meter
absorption_coeffs = absorption_coeffs * 100

# Convert to array and window the absorption coefficients to get a smooth absorption spectrum
absorption_coeffs = np.array(absorption_coeffs)
absorption_coeffs = absorption_coeffs*tukey(absorption_coeffs.size, 0.05)

# Insert calculation range into frequency range
result = np.zeros_like(freq_vector)
result[0:absorption_coeffs.size] = absorption_coeffs
absorption_coeffs = result

if plot:
    plt.yscale("log")
    plt.plot(freq_vector*1e-9, absorption_coeffs, label="mixture self-air")
    plt.xlabel('Frequency (GHz)')
    plt.ylabel('Absorption Coefficient (m^-1)')
    plt.title('Total Absorption of Air in the THz Range')
    plt.grid(True)
    plt.minorticks_on()
    plt.ylim([1e-5, 1e1])
    plt.xlim([0, 1000])
    plt.legend()
    plt.show()

# Using absorption coefficients to calculate extinction coefficient (imaginary part of refractive index) = (α(w)*c)/2*w
exctinction_coeffs = absorption_coeffs[1:]*speed_of_light/(2*w_vector[1:])

# avoiding division by zero problem by setting exctinction_coeffs[0] = 0 statically
exctinction_coeffs = np.insert(exctinction_coeffs, 0, 0)

# calculating real part of refractive index using imaginary part using the pyElli module (Kramers Kronig relation)
refractive_index = im2re(exctinction_coeffs, w_vector)

# adding refractive index of air
refractive_index = refractive_index + 1.0027

# defining complex refractive index
complex_refractive_index = refractive_index + 1j*exctinction_coeffs

# Define distance range
distances = np.arange(0.3, 0.595 + 0.005, 0.001)  # 30 cm to 60 cm, step 5 mm

# Placeholder to store transfer functions for each distance
transfer_functions = []

for distance in distances:
    # Compute transfer function for the current distance
    transfer_function = np.exp(distance * 1j * complex_refractive_index * w_vector / speed_of_light) * \
                        np.exp(distance * 1j * 1.0027 * w_vector / speed_of_light)
    transfer_function_noisy = np.random.normal(size=transfer_function.size) * 0.001 + transfer_function
    transfer_function = np.abs(transfer_function) * np.exp(-1j * np.angle(transfer_function))
    transfer_functions.append(transfer_function)

    if plot==0:
        # Plot Attenuation for the current distance
        transfer_function_1m = np.exp(distance * 1j * complex_refractive_index * w_vector / speed_of_light) * \
                               np.exp(-distance * 1j * 1.0027 * w_vector / speed_of_light)
        transfer_function_1m = np.abs(transfer_function_1m) * np.exp(-1j * np.angle(transfer_function_1m))
        transfer_function_1m_noisy = np.random.normal(size=transfer_function_1m.size) * 0.001 + transfer_function_1m
        
        plt.figure()
        plt.plot(freq_vector * 1e-9, 1000 * 20 * np.log10(np.abs(1 / transfer_function_1m)),
                 label=f"Distance: {distance * 100:.1f} cm")
        plt.title("Visualizing Magnitude of Transfer Function of Water Vapor Absorption Model")
        plt.ylabel("Attenuation in dB / km")
        plt.xlabel("Frequency (THz)")
        plt.yscale("log")
        plt.ylim([0.0001, 2e5])
        plt.xlim([0, 2500])
        plt.grid()
        plt.legend()

        # Plot Phase for the current distance
        plt.figure()
        plt.plot(freq_vector * 1e-9, np.unwrap(np.angle(transfer_function_1m)), label=f"Transfer Function {distance * 100:.1f} cm")
        plt.plot(freq_vector * 1e-9, np.unwrap(np.angle(transfer_function_1m_noisy)), label=f"Transfer Function {distance * 100:.1f} cm - Noisy")
        plt.title("Phase of Transfer Function")
        plt.ylabel("Phase (rad)")
        plt.xlabel("Frequency (THz)")
        plt.legend()

        # Impulse Response
        td_1m = np.fft.irfft(transfer_function_1m)
        td_1m = np.roll(td_1m, int(td_1m.size / 2))
        maxpos = np.argmax(np.abs(td_1m))
        window = np.zeros_like(td_1m)
        # Compute start and end indices safely
        start_idx = max(0, maxpos - 200)
        end_idx = min(window.size, maxpos + 2200)
        
        # Create a Tukey window of the appropriate size
        tukey_window = tukey(end_idx - start_idx, 0.05)
        
        # Assign the Tukey window to the appropriate slice of the `window` array
        window[start_idx:end_idx] = tukey_window
        window[maxpos - 200:maxpos + 2200] = tukey(2200 + 200, 0.05)
        tdwindowd_1m = td_1m * window

        # Plot Impulse Response
        plt.figure()
        plt.plot(t_vector * 1e12, np.real(td_1m), label="Unwindowed")
        plt.plot(t_vector * 1e12, np.real(tdwindowd_1m), label="Windowed")
        plt.title("Impulse Response for Water Vapor")
        plt.xlabel("Delay Time (ps)")
        plt.ylabel("Amplitude")
        plt.legend()
        plt.grid()
        plt.xlim(490, 700)

        # Magnitude of Impulse Response
        plt.figure()
        plt.plot(t_vector * 1e12, 20 * np.log10(np.abs(np.real(td_1m))), label="Unwindowed")
        plt.plot(t_vector * 1e12, 20 * np.log10(np.abs(np.real(tdwindowd_1m))), label="Windowed")
        plt.xlabel("Delay Time (ps)")
        plt.ylabel("Magnitude")
        plt.legend()
        plt.grid()

        # Frequency Response
        plt.figure()
        plt.plot(freq_vector * 1e-9, 20 * np.log10(np.abs(np.fft.rfft(np.real(td_1m)))), label="Unwindowed")
        plt.plot(freq_vector * 1e-9, 20 * np.log10(np.abs(np.fft.rfft(np.real(tdwindowd_1m)))), label="Windowed")
        plt.xlabel("Frequency (GHz)")
        plt.ylabel("Magnitude")
        plt.legend()
        plt.grid()


# Perform convolution with trace for each distance
for i, distance in enumerate(distances):
    td = np.fft.irfft(transfer_functions[i])
    td = td.astype(np.complex128)
    trace = dgmm(t_vector, 100e-12, -670.81e-12, -670.39e-12, 0.19, 0.24, -5.43, 3.82)
    #trace = resample(trace, 3000)
    trace = trace.astype(np.complex128)
    convolved = np.convolve(trace, td, mode="full")
    convolved = convolved[0:trace.size]
    if plot==0:
        # Convolved Signal
        plt.figure()
        plt.plot(t_vector * 1e12, trace, label="Generic THz-pulse")
        plt.plot(t_vector * 1e12, convolved, label=f"Convolved Pulse (Distance: {distance * 100:.1f} cm)")
        plt.plot(t_vector*1e12, np.real(np.fft.irfft(np.fft.rfft(trace)*transfer_functions[i])), label="TF Calculated")
        plt.ylabel("Amplitude (a.u.)")
        plt.xlabel("Delay Time (ps)")
        plt.xlim(98, 115)
        plt.legend()
        plt.grid()

        # Frequency Magnitude Comparison
        plt.figure()
        plt.plot(freq_vector * 1e-9, 20 * np.log10(np.abs(np.fft.rfft(trace))), label="Original Trace")
        plt.plot(freq_vector * 1e-9, 20 * np.log10(np.abs(np.fft.rfft(convolved))), label=f"Convolved Trace (Distance: {distance * 100:.1f} cm)")
        plt.plot(freq_vector * 1e-9, 20*np.log10(np.abs(np.fft.rfft(trace)*transfer_functions[i])), label="Multiplied TF")
        plt.ylabel("Magnitude (a.u. dB)")
        plt.xlabel("Frequency (GHz)")
        plt.legend()
        plt.grid()
        plt.xlim(0, 8000)


plt.show()
