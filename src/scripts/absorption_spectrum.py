# This scripts computes the transmitted pulse through air containing water vapor
# 1) The absorption spectrum for water vapor in air is calculated for a certain temperature, pressure, and humidity
# 2) The transfer function is calculated by taking into account the travelled distance through air d
#    A renormalization is taken by applying the inverse phase
# 3) A artificial terahertz pulse is generated taking into account the fitted terahertz pulse to the Tera-K15 system
#    measurement in transmission geometry
# 4) Resulting terahertz pulse is generated by flipping the transfer function of water and convolving it with the
#    terahertz pulse
#
# Implementation is missing of the relative humidity.
from idlelib.pyparse import trans

from hapi import *
import numpy as np
import matplotlib.pyplot as plt
from scipy.constants import speed_of_light
from elli.kkr.kkr import im2re, im2re_reciprocal
from scipy.signal.windows import tukey

plot = True

speed_of_light_cmps = speed_of_light*100    # Speed of light in cm^-1
dt = 33.3333e-15                            # Target sampling frequency
impulse_response_length = 1*1e-9            # Duration of desired impulse response

count_of_timepoints = int(np.floor(impulse_response_length / dt))
freq_vector = np.fft.rfftfreq(count_of_timepoints, dt)
t_vector = np.arange(count_of_timepoints)*dt
w_vector = 2*np.pi*freq_vector

def dgmm(timeaxis, t0, mu1, mu2, sigma1, sigma2, a1, a2):
    """
    Generates double gaussian distribution with the given parameters
    """
    timeaxis = timeaxis*1e12
    mu1 = mu1*1e12
    mu2 = mu2*1e12
    t0 = t0*1e12
    average_position = (mu2+mu1)/2
    mu1 = mu1-average_position+t0
    mu2 = mu2-average_position+t0

    return a1*np.exp(-((timeaxis-mu1)**2)/(2*sigma1**2))+a2*np.exp(-((timeaxis-mu2)**2)/(2*sigma2**2))

# Start frequency and stop frequency where the spectrum should be calculated in
start_frequency = freq_vector[0]
stop_frequency = freq_vector[-1]

step_frequency = freq_vector[1]-freq_vector[0]

start_frequency = 0
stop_frequency = 8e12

# Wavelength calculation
start_nu = start_frequency/speed_of_light_cmps
stop_nu = stop_frequency/speed_of_light_cmps
step_nu = step_frequency/speed_of_light_cmps
omega_grid = freq_vector/speed_of_light_cmps

print("Impulse response length: ", impulse_response_length)
print("Sampling time: ", dt)
print("f_start: ", freq_vector[0]*1e-12, "THz")
print("f_stop: ", freq_vector[-1]*1e-12, "THz")
print("Number of points", count_of_timepoints)

# The absorption spectrum must be recalculated when one of the following quantities has been changed:
# start_wavelength; stop_wavelength, wavelength step, air pressure, temperature.
# Concentrations can be caluclated afterwards

environment = {
    'pressure': 1,
    'temperature': 22+273.15,
    'relative_humidity': 0.55           # TODO Values must be specified
}

# Concentrations in volume percent for calculating the absorption in the volume
concentrations = {
    'N2': 0.78084,    # 0.78084, Stickstoff
    'O2': 0.20942,    # 20.942% Sauerstoff
    'CO2': 0.00040,   # 0.0415% Kohlendioxid (415 ppm)
    'H2O': 0.008      # 0.8% Wasserdampf (kann variieren), Hier 21°C und 55% rel. Luftfeuchtigkeit
                      # TODO mus be calculated from relative humidity
}

# Init Database
db_begin('data')

# Get Molecules and save into database, have to be fetched one time for
fetch('N2', 22, 1, start_nu, stop_nu)
fetch('O2', 7, 1, start_nu, stop_nu)
fetch('CO2', 2, 1, start_nu, stop_nu)
fetch('H2O', 1, 1, start_nu, stop_nu)
fetch('Ar', 1, 1, start_nu, stop_nu)

# Calculate spectras for every molecule
absorption_coeffs = 0
for molecule, concentration in concentrations.items():
    nu, coef = absorptionCoefficient_Voigt(
        SourceTables=molecule,
        Environment={'p': environment['pressure'], 'T': environment['temperature']},
        HITRAN_units=False,
        Diluent={'self': concentration, 'air': (1 - concentration)},
        WavenumberStep=step_nu,
        WavenumberRange=[start_nu, stop_nu]
    )

    # coef is the absorption coefficient per cm
    absorption_coeffs += coef * concentration

# Convert into absorption per meter
absorption_coeffs = absorption_coeffs * 100

# Convert to array and window the absorption coefficients to get a smooth absorption spectrum
absorption_coeffs = np.array(absorption_coeffs)
absorption_coeffs = absorption_coeffs*tukey(absorption_coeffs.size, 0.05)

# Insert calculation range into frequency range
result = np.zeros_like(freq_vector)
result[0:absorption_coeffs.size] = absorption_coeffs
absorption_coeffs = result

if plot:
    plt.yscale("log")
    plt.plot(freq_vector*1e-9, absorption_coeffs, label="mixture self-air")
    plt.xlabel('Frequency (GHz)')
    plt.ylabel('Absorption Coefficient (m^-1)')
    plt.title('Total Absorption of Air in the THz Range')
    plt.grid(True)
    plt.minorticks_on()
    plt.ylim([1e-5, 1e1])
    plt.xlim([0, 1000])
    plt.legend()
    plt.show()

# Using absorption coefficients to calculate extinction coefficient (imaginary part of refractive index) = (α(w)*c)/2*w
exctinction_coeffs = absorption_coeffs[1:]*speed_of_light/(2*w_vector[1:])

# avoiding division by zero problem by setting exctinction_coeffs[0] = 0 statically
exctinction_coeffs = np.insert(exctinction_coeffs, 0, 0)

# calculating real part of refractive index using imaginary part using the pyElli module (Kramers Kronig relation)
refractive_index = im2re(exctinction_coeffs, w_vector)

# adding refractive index of air
refractive_index = refractive_index + 1.0027

# defining complex refractive index
complex_refractive_index = refractive_index + 1j*exctinction_coeffs

distance = 1  # In m
transfer_function = np.exp(distance*1j*complex_refractive_index*w_vector/speed_of_light)*np.exp(-distance*1j*1.0027*w_vector/speed_of_light)
transfer_function_noisy = np.random.normal(size=transfer_function.size)*0.001+transfer_function
transfer_function = np.abs(transfer_function)*np.exp(-1j*np.angle(transfer_function))

if plot:
    # Plot Attenuation for 1km through water vapor without Continuum Spectrum
    transfer_function_1m = np.exp(1*1j*complex_refractive_index*w_vector/speed_of_light)*np.exp(-distance*1j*1.0027*w_vector/speed_of_light)
    transfer_function_1m = np.abs(transfer_function_1m) * np.exp(-1j * np.angle(transfer_function_1m))
    transfer_function_1m_noisy = np.random.normal(size=transfer_function_1m.size) * 0.001 + transfer_function_1m
    plt.figure()
    plt.plot(freq_vector*1e-9, 1000*20*np.log10(np.abs(1/transfer_function_1m)), label="Absolute value of transfer function")
    # plt.plot(freq_vector, 20*np.log10(np.abs(1/transfer_function_noisy)), label="Absolute value of transfer function - Noisy")
    # plt.plot(frequency_vector,np.real(transfer_function),"--",label="Real part of transfer function")
    # plt.plot(frequency_vector,np.imag(transfer_function),"--",label="Imaginary partof transfer function")
    plt.title("visualizing magnitude of transfer function of water vapour absorption model")
    plt.ylabel("Attenuation in dB / km")
    plt.xlabel("Frequency (THz)")
    plt.yscale("log")
    # plt.xscale("log")
    plt.ylim([0.0001, 2e5])
    plt.xlim([0, 2500])
    plt.grid()
    plt.legend()

    # Plot Transferfunction for 1m
    plt.figure()
    # plt.plot(freq_vector*1e-9,20*np.log10(np.abs(transfer_function)),label="Absolute value of transfer function")
    plt.plot(freq_vector*1e-9, np.unwrap(np.angle(transfer_function_1m)), label="Transferfunction 1m")
    plt.plot(freq_vector*1e-9, np.unwrap(np.angle(transfer_function_1m_noisy)),label="Transferfunction 1m - With Noise")
    # plt.plot(frequency_vector,np.real(transfer_function),"--",label="Real part of transfer function")
    # plt.plot(frequency_vector,np.imag(transfer_function),"--",label="Imaginary partof transfer function")
    plt.title("visualizing magnitude of transfer function of water vapour absorption model")
    plt.ylabel("Phase / rad")
    plt.xlabel("Frequency (THz)")
    plt.legend()

    td_1m = np.fft.irfft(transfer_function_1m)
    td_1m = np.roll(td_1m, int(td_1m.size/2))

    maxpos = np.argmax(np.abs(td_1m))
    window = np.zeros_like(td_1m)
    window[maxpos - 200:maxpos + 2200] = tukey(2200 + 200, 0.05)

    tdwindowd_1m = td_1m * window

    # tdwindowd_1m = np.roll(tdwindowd_1m, -int(tdwindowd_1m.size/2))

    # Plot difference between windowed and unwindowed
    plt.figure()
    plt.plot(t_vector*1e12, (np.real(td_1m)), label="Unwindowed")
    plt.plot(t_vector*1e12, (np.real(tdwindowd_1m)), label="Windowed")
    plt.title("Impulse response of water vapor for 1m travel distance")
    plt.xlabel("delay time / ps")
    plt.grid()
    plt.ylabel("amplitude")
    plt.legend()
    plt.xlim(490,700)
    plt.figure()


    plt.figure()
    plt.plot(t_vector*1e12, 20*np.log10(np.abs(np.real(td_1m))), label="Unwindowed")
    plt.plot(t_vector*1e12, 20*np.log10(np.abs(np.real(tdwindowd_1m))), label="Windowed")
    plt.xlabel("delay time / ps")
    plt.ylabel("magnitude")
    plt.grid()
    plt.legend()

    plt.figure()
    plt.plot(freq_vector * 1e-9, 20 * np.log10(np.abs(np.fft.rfft(np.real(td_1m)))), label="Unwindowed")
    plt.plot(freq_vector * 1e-9, 20 * np.log10(np.abs(np.fft.rfft(np.real(tdwindowd_1m)))), label="Windowed")
    plt.xlabel("frequency / GHz")
    plt.ylabel("magnitude")
    plt.grid()
    plt.legend()

td = np.fft.irfft(transfer_function)
# td = np.flip(td)
td = td.astype(np.complex128)
# Here, the trace is plotted at the position 100e-12
# The window is generated for the whole t_vector and is then convolved with the response of the water vapor
trace = dgmm(t_vector, 100e-12, -670.81e-12, -670.39e-12, 0.19, 0.24, -5.43, 3.82)
trace = trace.astype(np.complex128)

convolved = np.convolve(trace, td, mode="full")
convolved = convolved[0:trace.size]
print(convolved.dtype)
print(trace.dtype)
print(transfer_function.dtype)

if plot:
    plt.figure()
    plt.plot(t_vector*1e12, trace, label="Generic THz-pulse")
    plt.plot(t_vector*1e12, convolved, label="Convolved Generic THz-pulse with water wavpor")
    plt.plot(t_vector*1e12, np.real(np.fft.irfft(np.fft.rfft(trace)*transfer_function)), label="TF Calculated")
    plt.ylabel("amplitude / a.u.")
    plt.xlabel("delay time / ps")
    plt.xlim(98, 115)
    plt.legend()
    plt.grid()
    plt.figure()

    plt.figure()
    plt.plot(freq_vector * 1e-9, 20*np.log10(np.abs(np.fft.rfft(trace))), label="Original Trace")
    plt.plot(freq_vector * 1e-9, 20*np.log10(np.abs(np.fft.rfft(convolved))), label="Convolved Trace")
    plt.plot(freq_vector * 1e-9, 20*np.log10(np.abs(np.fft.rfft(trace)*transfer_function)), label="Multiplied TF")
    plt.ylabel("magnitude / a.u. dB.")
    plt.xlabel("frequency / GHz")
    plt.legend()
    plt.grid()
    plt.xlim(0, 8000)

plt.show()
